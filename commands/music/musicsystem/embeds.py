from utils.database import get_emoji_from_table, get_fun_emoji, get_music_emoji, get_error_emoji, get_number_emoji, get_clan_management_emoji, get_server_staff_emoji
import discord
from utils.database import get_embed_color, get_config
from utils.config import get_lema

def create_embed(title, description, color=None, banner=None):
    """
    Cria uma mensagem embed personalizada com o lema e o nome do cl√£.

    :param title: T√≠tulo do embed.
    :param description: Descri√ß√£o do embed.
    :param color: Cor personalizada para o embed (opcional).
    :param banner: URL da imagem para o banner do embed (opcional).
    :return: Um objeto discord.Embed configurado.
    """
    # Define a cor padr√£o se nenhuma cor for fornecida
    color = color or get_embed_color()
    embed = discord.Embed(title=title, description=description, color=color)

    # Obt√©m os valores do lema, imagem do lema e nome do cl√£
    lema, lema_img, nome_do_cla = get_lema()

    # Adiciona o rodap√© com o lema e a imagem do lema (se dispon√≠vel)
    if lema_img:
        embed.set_footer(text=f"{nome_do_cla} ‚Ä¢ {lema}", icon_url=lema_img)
    else:
        embed.set_footer(text=f"{nome_do_cla} ‚Ä¢ {lema}")

    # Adiciona o banner, se fornecido
    if banner:
        embed.set_image(url=banner)

    return embed

def embed_now_playing(song, voice_channel):
    """
    Gera um embed para exibir informa√ß√µes da m√∫sica atualmente tocando.

    :param song: Dicion√°rio contendo informa√ß√µes da m√∫sica atual.
    :param voice_channel: O canal de voz onde o bot est√° conectado.
    :return: Um embed configurado.
    """
    embed = discord.Embed(
        title=f"{get_music_emoji("music_now")} Tocando Agora",
        description=(
            f"**T√≠tulo:** [{song.get('title', 'Desconhecido')}]({song.get('url', '#')})\n"
            f"{get_music_emoji("music_youtube")}**Canal do YouTube:** {song.get('uploader', 'Desconhecido')}\n"
            f"{get_music_emoji("music_duration")}**Dura√ß√£o:** {format_duration(song.get('duration', 0))}\n"
            f"{get_music_emoji("music_user")}**Adicionado por:** <@{song.get('added_by', 'Desconhecido')}>\n"
            f"**Canal de Voz:** <#{voice_channel.id}>"
        ),
        color=get_embed_color()
    )
    # Adiciona uma imagem (thumbnail) se dispon√≠vel
    if song.get('thumbnail'):
        embed.set_thumbnail(url=song['thumbnail'])
    return embed

def embed_queue_empty():
    """
    Embed para quando a fila est√° vazia.
    """
    return create_embed(
        "üé∂ Fila Vazia",
        "Adicione mais m√∫sicas para continuar a reprodu√ß√£o."
    )

def embed_need_to_be_connected_in_voice_channel():
    """
    Embed para exibir erro caso o usu√°rio n√£o esteja conectado em um canal de voz.
    """
    return create_embed(
        "‚ùå Erro",
        "Voc√™ precisa estar conectado em um canal de voz para usar esse comando."
    )

def embed_dj_error():
    """
    Embed para exibir erro sobre dono da sess√£o e a tag de DJ.
    """
    return create_embed(
        "üö´ Sem permiss√£o",
        f"Voc√™ precisa ser o dono da sess√£o ou possuir o cargo <@&{get_config('TAG_DJ')}> para executar esse comando."
    )

def embed_already_being_used_only_owner_can_move(current_channel):
    """
    Embed para exibir que o bot j√° est√° sendo usado e que apenas o dono da sess√£o pode chamar o bot..
    """
    return create_embed(
        "‚ùå Erro",
        f"J√° estou tocando m√∫sica no canal **{current_channel.name}**. Apenas o dono da sess√£o pode me mover."
    )

def embed_user_not_in_same_channel():
    """
    Embed para exibir erro caso o usu√°rio n√£o esteja na mesma call.
    """
    return create_embed(
        "‚ö†Ô∏è Erro",
        "Voc√™ precisa estar no mesmo canal que o bot."
    )

def embed_no_music_paused():
    """
    Embed para exibir erro se tentar resumir n√£o estando pausado.
    """
    return create_embed(
        "‚ö†Ô∏è Erro",
        "N√£o h√° nenhuma m√∫sica pausada no momento."
    )

def embed_remove_usage():
    return create_embed(
        "‚ùå Uso do Comando",
        "Para remover uma m√∫sica, forne√ßa o link dela como par√¢metro.\nExemplo: `hp!remove <link>`"
    )

def embed_song_removed(song):
    return create_embed(
        "üé∂ M√∫sica Removida",
        f"A m√∫sica **{song['title']}** foi removida da fila."
    )


def embed_error(message, error_detail=""):
    """
    Embed para exibir erros.
    """
    return create_embed(
        "Erro",
        f"‚ö†Ô∏è {message}\n{error_detail}"
    )

def embed_queue_song_added(song, voice_channel, added_by, is_playlist=False, playlist_name=None, user=None):
    """
    Embed para exibir m√∫sica adicionada √† fila.
    Se for uma playlist salva, mostra o nome da playlist e usa o avatar do usu√°rio.
    """
    if is_playlist and user:
        banner = user.avatar.url if hasattr(user, 'avatar') and user.avatar else None
        description = (
            f"**Playlist:** {playlist_name}\n"
            f"**Adicionado por:** <@{added_by}>"
        )
    else:
        banner = song.get('thumbnail')
        description = (
            f"**T√≠tulo:** {song['title']}\n"
            f"**Canal:** {song.get('uploader', 'Desconhecido')}\n"
            f"**Dura√ß√£o:** {format_duration(song['duration'])}\n"
            f"**Adicionado por:** <@{added_by}>\n"
            f"**Canal de Voz:** <#{voice_channel.id}>"
        )

    return create_embed(
        "üé∂ M√∫sica Adicionada",
        description,
        banner=banner
    )

def embed_loop_single():
    """
    Embed para ativar repeti√ß√£o de m√∫sica atual.
    """
    return create_embed(
        "üîÇ Repeti√ß√£o de m√∫sica ativada",
        "A m√∫sica atual ser√° repetida."
    )

def embed_loop_all():
    """
    Embed para ativar repeti√ß√£o de todas as m√∫sicas.
    """
    return create_embed(
        "üîÅ Repeti√ß√£o de todas as m√∫sicas ativada",
        "Todas as m√∫sicas da fila ser√£o repetidas."
    )

def embed_loop_off():
    """
    Embed para desligar a repeti√ß√£o.
    """
    return create_embed(
        "‚èπÔ∏è Repeti√ß√£o desligada",
        "Nenhuma m√∫sica ser√° repetida."
    )

def embed_loop_cancel():
    """
    Embed para cancelar o comando de loop.
    """
    return create_embed(
        "‚ùå Comando cancelado",
        "Nenhuma altera√ß√£o foi feita no modo de repeti√ß√£o."
    )

def embed_loop_timeout():
    """
    Embed para tempo esgotado na escolha de op√ß√£o.
    """
    return create_embed(
        "‚è≥ Tempo Esgotado",
        "N√£o foi poss√≠vel concluir a escolha. Tente novamente."
    )

def embed_shuffle_success():
    """
    Embed para exibir que a fila foi embaralhada com sucesso.
    """
    return create_embed(
        "üé∂ Fila Embaralhada",
        "A fila de m√∫sicas foi embaralhada com sucesso!"
    )

def embed_shuffle_error_no_songs():
    """
    Embed para exibir erro caso a fila esteja vazia.
    """
    return create_embed(
        "‚ö†Ô∏è Erro",
        "N√£o h√° m√∫sicas suficientes na fila para embaralhar."
    )

def embed_queue_cleared():
    """
    Embed para exibir que a fila foi limpa com sucesso.
    """
    return create_embed(
        "üéµ Fila Limpa",
        "‚úÖ A fila de m√∫sicas foi limpa com sucesso."
    )

def embed_stop_music():
    """
    Embed para exibir que a m√∫sica foi parada e a fila limpa.
    """
    return create_embed(
        "‚èπ M√∫sica Parada",
        "Fila limpa."
    )

def embed_connected(channel_name):
    """
    Embed para exibir que o bot entrou no canal de voz.
    """
    return create_embed(
        "Conectado",
        f"‚úÖ Entrei no canal **{channel_name}**."
    )

def embed_disconnected(channel_name):
    """
    Embed para exibir que o bot saiu do canal de voz.
    """
    return create_embed(
        "Desconectado",
        f"‚õî Sa√≠ do canal **{channel_name}**."
    )

def embed_volume_set(volume):
    """
    Embed para exibir que o volume foi ajustado.
    """
    return create_embed(
        "üîä Volume Ajustado",
        f"O volume foi ajustado para **{volume}%**."
    )

def embed_current_volume(volume):
    """
    Embed para exibir o volume atual.
    """
    return create_embed(
        "üîä Volume Atual",
        f"O volume atual √© **{int(volume)}%**."
    )

def embed_music_resumed():
    """
    Embed para exibir que a m√∫sica foi retomada.
    """
    return create_embed(
        "‚ñ∂Ô∏è M√∫sica Retomada",
        "A m√∫sica pausada foi retomada."
    )

def embed_music_paused(song):
    """
    Embed para exibir que a m√∫sica foi pausada.
    """
    banner = song.get('thumbnail')
    return create_embed(
        "‚è∏Ô∏è M√∫sica Pausada",
        f"A m√∫sica **{song['title']}** foi pausada.",
        banner=banner
    )

def embed_permission_denied(message):
    """
    Embed para indicar permiss√£o negada.
    """
    return create_embed(
        "Permiss√£o Negada",
        f"‚ö†Ô∏è {message}"
    )

def embed_song_skipped(song):
    """
    Embed para exibir que a m√∫sica foi pulada.
    """
    banner = song.get('thumbnail')
    return create_embed(
        "‚è≠Ô∏è M√∫sica Pulada",
        f"**Agora Tocando:** {song['title']}\n"
        f"**Canal:** {song.get('uploader', 'Desconhecido')}\n"
        f"**Dura√ß√£o:** {format_duration(song['duration'])}\n"
        f"**Adicionado por:** <@{song['added_by']}>",
        banner=banner
    )

def embed_playlist_added(title, uploader, valid_songs, total_duration, thumbnail, user):
    """
    Embed para exibir que uma playlist foi adicionada √† fila.
    """
    return create_embed(
        "üé∂ Playlist Adicionada",
        f"**T√≠tulo:** {title}\n"
        f"**Uploader:** {uploader}\n"
        f"**Quantidade de M√∫sicas:** {valid_songs}\n"
        f"**Dura√ß√£o Total:** {format_duration(total_duration)}\n"
        f"**Adicionada por:** {user.mention}",
        banner=thumbnail
    )

def embed_playlist_menu(description=None):
    """
    Gera um embed para o menu principal de playlists.

    :param description: Uma descri√ß√£o opcional para exibir no embed (ex.: lista de playlists do usu√°rio).
    :return: Um embed configurado.
    """
    embed = discord.Embed(
        title="üéµ Menu de Playlists",
        description=description or (
            "Selecione uma das op√ß√µes:\n\n"
            "1Ô∏è‚É£ Salvar a playlist atual\n"
            "2Ô∏è‚É£ Carregar uma playlist salva\n"
            "3Ô∏è‚É£ Deletar uma playlist salva\n"
            "4Ô∏è‚É£ Deletar todas as playlists"
        ),
        color=get_embed_color()
    )
    embed.set_footer(text="Digite o n√∫mero correspondente √† op√ß√£o desejada.")
    return embed

def embed_save_playlist():
    """
    Embed para solicitar o nome da playlist a ser salva.
    """
    return create_embed(
        "üé∂ Salvar Playlist",
        "Digite o nome da sua playlist:"
    )

def embed_playlist_saved(playlist_name, total_duration, user):
    """
    Embed para exibir que a playlist foi salva.
    """
    return create_embed(
        "üéâ Playlist Salva",
        f"Playlist salva como **{playlist_name}**.\n"
        f"**Dura√ß√£o Total:** {format_duration(total_duration)}\n"
        f"Criada por: {user.mention}"
    )

def embed_playlist_loaded(playlist_name, song_count, total_duration, user):
    """
    Embed para exibir que a playlist foi carregada.
    """
    return create_embed(
        "üé∂ Playlist Carregada",
        f"**T√≠tulo:** {playlist_name}\n"
        f"**Quantidade de M√∫sicas:** {song_count}\n"
        f"**Dura√ß√£o Total:** {format_duration(total_duration)}\n"
        f"**Adicionada por:** {user.mention}"
    )

def embed_previous_song(song):
    """
    Embed para exibir a m√∫sica anterior tocada.
    """
    banner = song.get('thumbnail')
    return create_embed(
        "‚èÆÔ∏è Voltando para a M√∫sica Anterior",
        f"**T√≠tulo:** {song['title']}\n"
        f"**Canal:** {song.get('uploader', 'Desconhecido')}\n"
        f"**Dura√ß√£o:** {format_duration(song['duration'])}\n"
        f"**Adicionado por:** <@{song['added_by']}>",
        banner=banner
    )

def embed_queue_page(page, total_pages, description):
    """
    Embed para exibir uma p√°gina da fila de m√∫sicas.
    """
    return create_embed(
        "üé∂ Fila de Reprodu√ß√£o",
        description,
        color=get_embed_color()
    ).set_footer(text=f"P√°gina {page}/{total_pages}")

def embed_download_error():
    """
    Embed para exibir erro de download.
    """
    return create_embed(
        "Erro de Download",
        "‚ö†Ô∏è N√£o foi poss√≠vel processar a m√∫sica devido a um erro de download."
    )

def embed_unexpected_error():
    """
    Embed para exibir erro inesperado.
    """
    return create_embed(
        "Erro Inesperado",
        "‚ö†Ô∏è Ocorreu um erro inesperado."
    )

def embed_all_playlists_deleted():
    """
    Embed para exibir que todas as playlists foram apagadas.
    """
    return create_embed(
        "üéâ Todas as Playlists Apagadas",
        "Todas as suas playlists foram apagadas com sucesso."
    )

def embed_play_usage():
    """
    Embed para exibir o uso correto do comando play.
    """
    return create_embed(
        "Como Usar o Comando play",
        "‚ö†Ô∏è **Uso do Comando play** ‚ö†Ô∏è\n\n"
        "**Op√ß√µes de uso:**\n"
        "- Link do YouTube: `https://youtube.com/watch?v=<ID>`\n"
        "- Nome da M√∫sica: Exemplo: `Bohemian Rhapsody`\n"
        "- Playlist do YouTube: `https://youtube.com/playlist?list=<ID>`\n\n"
        "**Exemplos de Comando:**\n"
        "- `!play https://youtube.com/watch?v=xxxxxx`\n"
        "- `!play Nome da M√∫sica`\n"
        "- `!play https://youtube.com/playlist?list=xxxxxx`"
    )

def format_duration(seconds):
    """
    Formata a dura√ß√£o em segundos para o formato HH:MM:SS.
    """
    hours, remainder = divmod(seconds, 3600)
    minutes, seconds = divmod(remainder, 60)
    return f"{hours:02}:{minutes:02}:{seconds:02}"

def embed_lyrics(title, artist, lyrics):
    """
    Embed para exibir a letra da m√∫sica em um formato bem estruturado.
    """
    embed = discord.Embed(
        title="",  # T√≠tulo da m√∫sica como t√≠tulo principal
        description=(
            f"# {title}\n"
            f"**{artist}**\n\n"  # Artista em negrito
            f"{lyrics}"          # Letra da m√∫sica
        ),
        color=get_embed_color()  # Utiliza a cor padr√£o configurada
    )
    embed.set_footer(text=get_config("LEMA"))  # Adiciona o lema como rodap√©
    return embed

def embed_radio_menu(radios):
    """
    Gera um embed para exibir o menu de r√°dios.

    :param radios: Lista de r√°dios.
    :return: Um embed configurado.
    """
    description = "\n".join([f"**{i+1}.** {radio['name']}" for i, radio in enumerate(radios)]) + "\n**18.** Desligar R√°dio"
    return create_embed(
        "üéµ Menu de R√°dios",
        f"Escolha uma r√°dio digitando o n√∫mero correspondente:\n\n{description}"
    )

def embed_searching_lyrics(title):
    """
    Gera um embed para informar que a letra est√° sendo pesquisada.

    :param title: T√≠tulo da m√∫sica que est√° sendo pesquisada.
    :return: Um embed configurado.
    """
    embed = discord.Embed(
        title="üîç Buscando Letra da M√∫sica",
        description=f"Aguarde enquanto buscamos a letra para **{title}**.",
        color=get_embed_color()
    )
    return embed

def embed_radio_now_playing(radio_name, stream_url, banner_url, user):
    """
    Gera um embed para exibir informa√ß√µes da r√°dio atualmente tocando.

    :param radio_name: Nome da r√°dio.
    :param stream_url: URL do stream.
    :param banner_url: URL do banner da r√°dio.
    :param user: Usu√°rio que iniciou a reprodu√ß√£o.
    :return: Um embed configurado.
    """
    description = (
        f"üéôÔ∏è **R√°dio:** {radio_name}\n"
        f"üîó **Stream:** [Clique aqui para ouvir]({stream_url})\n"
        f"üë§ **Solicitada por:** {user.mention}"
    )
    return create_embed(
        "üìª R√°dio Tocando Agora",
        description,
        banner=banner_url
    )


def embed_radio_stopped():
    """
    Gera um embed para informar que a r√°dio foi desligada.

    :return: Um embed configurado.
    """
    return create_embed(
        "üîá R√°dio Desligada",
        "A reprodu√ß√£o foi encerrada. Escolha outra r√°dio para sintonizar ou continue sua experi√™ncia musical!"
    )

